import numpy as np
import mahotas as mh
#from pylab import imshow, show
import pyfits
from msgfitter import fitgaussian
import os


def centroid(im, mask=None, w=None, x=None, y=None):
    """Compute the centroid of an image with a specified binary mask projected upon it.
    
    INPUT:
      im -- image array
      mask -- binary mask, 0 in ignored regions and 1 in desired regions
      w is typically 1.0/u**2, where u is the uncertainty on im
      x,y are those generated by meshgrid.

    OUTPUT:
      (x0,y0) tuple of centroid location"""
    from numpy import ones, arange, meshgrid
    # 2009-09-02 13:35 IJC: Created
    if mask is None:
        mask = ones(im.shape)
    #if w==None:
    #    w = ones(im.shape)
    if not (im.shape==mask.shape):
        print ("Image, mask, and weights must have same shape! Exiting.")
        return -1
    if x==None or y==None:
        xx = arange(im.shape[1])
        yy = arange(im.shape[0])
        x,y = meshgrid(xx,yy)
    if w==None:
        zz=im*mask    
    else:
        zz=im*mask*w        
    z=zz.sum()    
    x0 = (x*zz).sum()/z
    y0 = (y*zz).sum()/z

    return (x0,y0)

def mfind(array, label):
    a=np.where(array==label)
    return a


# definition of sort which sorts the column of a matrix
# input : array like
# output : [B,I] with B the sorted matrix and I the index matrix
def sort(A):
    B = np.zeros(A.shape)
    I = np.zeros(A.shape)
    for i in range(0, A.shape[1]):
        B[:, i] = np.sort(A[:, i])
        I[:, i] = sorted(range(A.shape[0]), key=lambda v: A[v, i])
    return [B, I]


def im2bw(image,level):
    # M.Schubnell - faking the matlab im2bw function
    s = np.shape(image)
    bw=np.zeros(s,dtype=int)
    threshold_indices = image > level
    bw[threshold_indices] = 1
    return bw

def multiCens(img, n_centroids_to_keep=2, verbose=False, write_fits=True, no_otsu=False):
# Computes centroids by finding spots and then fitting 2d gaussian
#
# Input 
#       img: image as numpy array
#       V: verbose mode
#
# Output:
#       returning the centroids and FWHMs as lists (xcen,ycen,fwhm)

    size_fitbox=10 # gaussian fitter box (1/2 length of side in pixels, i.e. 2*size_fitbox X 2*size_fitbox
    img[img<0]=0
    img = img.astype(np.uint16)
    level_fraction_of_peak = 0.1
    level_frac = int(level_fraction_of_peak*np.max(np.max(img)))
    if no_otsu:
        level = level_frac
    else:
        level_otsu = mh.thresholding.otsu(img)
        level = max(level_otsu,level_frac)
    bw=im2bw(img,level)
    hdu=pyfits.PrimaryHDU(bw)
    if write_fits:
        filename = '_binary_image.FITS'
        try:
            os.remove(filename)
        except:
            pass
        hdu.writeto(filename)
    else:
        filename = []
    labeled, nr_objects = mh.label(bw)
    sizes = mh.labeled.labeled_size(labeled) # size[0] is the background size, sizes[1 and greater] are number of pixels in each region
    sorted_sizes_indexes = np.argsort(sizes)[::-1] # return in descending order
    good_spot_indexes = sorted_sizes_indexes[1:n_centroids_to_keep+1] # avoiding the background regions entry at the beginning

    # In rare cases of having many bright spots and just a small # of dimmer (but still
    # usable) spots, then the otsu level is too high. In that case, we can retry, forcing
    # the more simplistic level_frac.
    if len(good_spot_indexes) < n_centroids_to_keep and not(no_otsu):
        print('Retrying centroiding using fractional level (' + str(level_fraction_of_peak) + ' * peak) instead of otsu method')
        return multiCens(img,n_centroids_to_keep,verbose,write_fits,no_otsu=True)

    # now loop over the found spots and calculate rough centroids        
    FWHMSub = []
    xCenSub = []
    yCenSub = []        
    peaks = []
    for spot in good_spot_indexes:
        selected=np.copy(labeled)
        selected[selected!=spot]=0
        xcen,ycen=centroid(img, mask=selected, w=None, x=None, y=None)
        nbox = size_fitbox
        px=int(round(xcen))
        py=int(round(ycen))        
        data = img[py-nbox:py+nbox,px-nbox:px+nbox]
        params = fitgaussian(data)
        xCenSub.append(float(px)-float(nbox)+params[3])
        yCenSub.append(float(py)-float(nbox)+params[2])
        FWHMSub.append(2.355*max(params[4],params[5]))
        peak = params[1]
        peaks.append(peak)
        should_save_sample_image = False
        if peak < 0 or peak > 2**16-1:
            print('peak = ' + str(peak) + ' brightness appears out of expected range')
            should_save_sample_image = True
        if FWHMSub[-1] < 0:
            print('fwhm = ' + str(FWHMSub[-1]) + ' appears invalid, check fitbox size')
            should_save_sample_image = True
        if should_save_sample_image:
            savefile = 'peak_' + format(peak,'.1f') + '_fwhm_' + format(FWHMSub[-1],'.3f') + '.FITS'
            sample = pyfits.PrimaryHDU(img)
            sample.writeto(savefile)
            print('wrote a sample image file to ' + savefile)
            
    return xCenSub, yCenSub, peaks, FWHMSub, filename
