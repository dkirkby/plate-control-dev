+import numpy as np
import mahotas as mh
#from pylab import imshow, show
import pyfits
from msgfitter import fitgaussian
import os


def centroid(im, mask=None, w=None, x=None, y=None):
	"""Compute the centroid of an image with a specified binary mask projected upon it.
	
	INPUT:
	  im -- image array
	  mask -- binary mask, 0 in ignored regions and 1 in desired regions
	  w is typically 1.0/u**2, where u is the uncertainty on im
	  x,y are those generated by meshgrid.

	OUTPUT:
	  (x0,y0) tuple of centroid location"""
	from numpy import ones, arange, meshgrid
	# 2009-09-02 13:35 IJC: Created
	if mask is None:
		mask = ones(im.shape)
	if w==None:
		w = ones(im.shape)
	if not (im.shape==mask.shape and im.shape==w.shape):
		print ("Image, mask, and weights must have same shape! Exiting.")
		return -1
	if x==None or y==None:
		xx = arange(im.shape[1])
		yy = arange(im.shape[0])
		x,y = meshgrid(xx,yy)
	zz=im*mask*w    
	z=zz.sum()    
	x0 = (x*zz).sum()/z
	y0 = (y*zz).sum()/z

	return (x0,y0)

def mfind(array, label):
	a=np.where(array==label)
	return a


# definition of sort which sorts the column of a matrix
# input : array like
# output : [B,I] with B the sorted matrix and I the index matrix
def sort(A):
	B = np.zeros(A.shape)
	I = np.zeros(A.shape)
	for i in range(0, A.shape[1]):
		B[:, i] = np.sort(A[:, i])
		I[:, i] = sorted(range(A.shape[0]), key=lambda v: A[v, i])
	return [B, I]


def im2bw(image,level):
	# M.Schubnell - faking the matlab im2bw function
	s = np.shape(image)
	bw=np.zeros(s,dtype=int)
	threshold_indices = image > level
	bw[threshold_indices] = 1
	return bw

def multiCens(img, n_centroids_to_keep=2, verbose=False, write_fits=False):
# Computes centroids by finding spots and then fitting 2d gaussian
#
# Input 
#       img: image as numpy array
#       V: verbose mode
#
# Output:
#       returning the centroids and FWHMs as lists (xcen,ycen,fwhm)

	level_fraction_of_peak = 0.1
	size_fitbox=20 # gaussian fitter box (length of side in pixels)
	img[img<0]=0
	img = img.astype(np.uint16)
	level_otsu = mh.thresholding.otsu(img)
	level_frac = int(level_fraction_of_peak*np.max(np.max(img)))
	level = max(level_otsu,level_frac)
	bw=im2bw(img,level)
	hdu=pyfits.PrimaryHDU(bw)
	if write_fits:
		filename = '_binary_image.FITS'
		try:
			os.remove(filename)
		except:
			pass
		hdu.writeto(filename)
	else:
		filename = []
	labeled, nr_objects = mh.label(bw)
	sizes = mh.labeled.labeled_size(labeled) # size[0] is the background size, sizes[1 and greater] are number of pixels in each region
	sorted_sizes_indexes = np.argsort(sizes)[::-1] # return in descending order
	good_spot_indexes = sorted_sizes_indexes[1:n_centroids_to_keep+1] # avoiding the background regions entry at the beginning

	# now loop over the found spots and calculate rough centroids		
	FWHMSub = []
	xCenSub = []
	yCenSub = []        
	for spot in good_spot_indexes:
		selected=np.copy(labeled)
		selected[selected!=spot]=0
		xcen,ycen=centroid(img, mask=selected, w=None, x=None, y=None)
		nbox = size_fitbox
		px=int(round(xcen))
		py=int(round(ycen))		
		data = img[py-nbox:py+nbox,px-nbox:px+nbox]
		params = fitgaussian(data)
		xCenSub.append(float(px)-float(nbox)+params[3])
		yCenSub.append(float(py)-float(nbox)+params[2])
		FWHMSub.append(2.355*max(params[4],params[5]))

	return xCenSub, yCenSub, FWHMSub, filename
