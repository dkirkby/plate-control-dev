# -*- coding: utf-8 -*-
"""Command-line tool to convert one or more csv files, containing xy target sets
in the older (prior to Sept 8, 2020) format to version supported by run_sequence.py.
"""


import argparse
parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument('-i', '--infiles', type=str, required=True, nargs='*',
                    help='Path to input csv file(s), containing results from "get_posmoves --with-calib" ' +
                         '(see that function''s help for full syntax). Regex is ok (like M*.csv). Multiple ' +
                         'file args are also ok (like M00001.csv M00002.csv M01*.csv), as is a directory ' +
                         'that contains the files.')
parser.add_argument('-o', '--outdir', type=str, required=True, help='Path to directory where to save output files.')
args = parser.parse_args()

import os
import sys
import glob
sys.path.append(os.path.abspath('../../pecs/'))
import sequence
from astropy.table import Table

# paths
infiles = []
for s in args.infiles:
    these = glob.glob(s)
    for this in these:
        if os.path.isdir(this):
            contents = os.listdir(this)
            contents = [os.path.join(this, file) for file in contents]
            infiles.extend(contents)
        else:
            infiles.append(this)
infiles = [os.path.realpath(p) for p in infiles]
save_dir = os.path.realpath(args.outdir)
if not os.path.isdir(save_dir):
    os.path.os.makedirs(save_dir)

commands_map = {'QS': ['Q','S'],
                'obsXY': ['obsX', 'obsY'],
                'ptlXY': ['ptlX', 'ptlY'],
                'poslocXY': ['poslocX', 'poslocY'],
                'poslocTP': ['poslocT', 'poslocP'],
                'posintTP': ['posintT', 'posintP'],
                }

ignore_cols = {'col0', 'target_no'}

for path in infiles:
    if 'csv' not in os.path.splitext(path)[-1]:
        print(f'skipping non-csv: {path}')
        continue
    basename = os.path.basename(path)
    name = os.path.splitext(basename)[0]
    suffix = name.split('xytest_targets_')[1]
    assert suffix, 'unrecognized input filename'
    runstamp = suffix.split('_')[0]
    assert len(runstamp) == 6, 'unrecognized input filename'
    print(f'processing: {path}')
    table = Table.read(path)
    table.sort('target_no')
    seq = sequence.Sequence(short_name=f'xytest_{suffix}',
                            long_name=f'xy test sequence {suffix}, generated by harness.py',
                            details='')
    command_cols = {x for x in table.columns if x not in ignore_cols}
    commands = {x.split('_')[0] for x in command_cols}
    assert len(commands) == 2, 'unrecognized commands format'
    test_command = commands.pop()
    cmd = ''
    for unified, pair in commands_map.items():
        if test_command in pair:
            cmd = unified
            cmd_pair = pair
            break
    assert cmd, f'{test_command} not recognized or not yet implemented in converter'
    locs = {int(x.split('_')[1]) for x in command_cols}
    locs = sorted(locs)
    for row in table:
        kwargs = {'command': cmd,
                  'target0': [],
                  'target1': [],
                  'device_loc': locs,
                  'log_note': runstamp,
                  'pos_settings': {},
                  'allow_corr': True}
        for loc in locs:
            for i in [0,1]:
                key = cmd_pair[i] + f'_{loc}'
                value = row[key]
                kwargs[f'target{i}'].append(value)
        move = sequence.Move(**kwargs)
        seq.append(move)
    seq.save(directory=save_dir)