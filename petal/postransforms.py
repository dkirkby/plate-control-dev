import sys
import math
import posconstants as pc
import petaltransforms
import xy2tp

class PosTransforms(petaltransforms.PetalTransforms):
    """This class provides transformations between positioner coordinate systems.
    
    All coordinate transforms must be done via the methods provided here.
    This ensures consistent and invertible definitions.
    
    For some historical information and why the module is structured as it is,
    see diagram and comments in DESI-5294.

    INITIALIZATION ARGUMENTS:
    -------------------------
        this_posmodel [optional] 
            When calibration values are to be drawn from some real- world
            source like the online database or a positioner config files,
            then a posmodel instance should be provided here. That posmodel in
            turn should have been initialized with appropriate state variables.
                          
            If no posmodel has been argued, and if stateless=False, then a
            dummy posmodel with nominal values will be generated internally.
                          
        petal_alignment [optional]
            Dictionary of six values defining the petal's rigid-body position
            in the focal plane. See parent module PetalTransforms.
        
        stateless [optional]
            Boolean. If the initialization argument stateless=True, then no
            PosModel instance is generated, and range limits are always
            defaulted to 'exact'. In this case, only the alt calibration values
            are used. Much initialization overhead is removed, but the handling
            of physical travel ranges is limited.

    COORDINATE SYSTEMS:
    -------------------
    The supported coordinate systems are:

        posintTP:   internally-tracked expected (theta, phi) of gearmotor
                    shafts at output of gear heads, pos origin
                    theta offset depends on the individual rotation of
                    positioner when installed formerly posTP

        poslocTP:   (theta, phi) in the positioner local CS, aligned with
                    petal flatXY, centred on theta axis

        poslocXY:   (x, y) in the positioner local CS, aligned with
                    petal flatXY, centred on theta axis

        flatXY:     Slightly-warped (x, y), in the petal local flat CS, locally
                    tangent to the focal surface. Generated by approximating
                    the surface coordinate Q ~ polar coordinate R.
        
        ptlXY:      Cartesian (x, y) in the petal local coordinates.
                    Subset of ptlXYZ from parent class PetalTransforms.
                    
        QS:         Natural coordinates of focal surface, with Q giving angle
                    about optical axis, and S giving path distance along asphere
                    from the optical axis. See DESI-0530.
                    Subset of QST from parent class PetalTransforms.
        
        obsXY:      Cartesian global (x, y) as seen by an observer such as
                    the fiber view camera.
                    Subset of obsXYZ from parent class PetalTransforms.

    PROTECTED VECTOR ADDITION AND SUBTRACTION OPERATIONS,
    ACCOUNTING FOR THE ROBOT'S PHYSICAL TRAVEL RANGE:
    -----------------------------------------------------
    The theta axis has a physical travel range wider than +/-180 degrees.
    Simple vector addition and subtraction is not sufficient when delta values
    cross the theta hardstop near +/-180. Therefore special methods are
    provided for performing addition and subtraction operations between two
    points, with angle-wrapping logic included.

        delta_posTP  ... is like dtdp = tp1 - tp0
        delta_obsTP
        addto_posTP  ... is like tp1 = tp0 + dtdtp
        addto_obsTP

    To round out the syntax, similar delta_ and addto_ methods are provided for
    the other coordinate systems. These are convenicence methods to do the
    vector subtraction or addition.

    COMMENTS ON Q ~ R APPROXIMATION:
    --------------------------------
    Note in practice that the coordinate S is similar, but not identical, to
    the radial distance R from the optical axis. This similarity is because the
    DESI focal plate curvature is gentle. See DESI-0530 for detail on the (Q,S)
    coordinate system.
    """
    
    alt_keys = ['LENGTH_R1', 'LENGTH_R2', 'OFFSET_T', 'OFFSET_P', 'OFFSET_X', 'OFFSET_Y']
    alt = {key:pc.nominals[key]['value'] for key in alt_keys}
    stateless_range_limits = [[-179.999999999, 180.0], [-20.0, 200.0]]
    exact_range_limits = [[-179.999999999, 180.0], [0.0, 180.0]]

    def __init__(self, this_posmodel=None, petal_alignment=None, stateless=False):
        if petal_alignment is None:
            petal_alignment = {'Tx': 0, 'Ty': 0, 'Tz': 0,
                               'alpha': 0, 'beta': 0, 'gamma': 0}
        super().__init__(Tx=petal_alignment['Tx'],
                         Ty=petal_alignment['Ty'],
                         Tz=petal_alignment['Tz'],
                         alpha=petal_alignment['alpha'],
                         beta=petal_alignment['beta'],
                         gamma=petal_alignment['gamma'], curved=True)
        self.alt = PosTransforms.alt.copy()
        if stateless:
            self.stateless = True
            self.posmodel = None
            self.alt_override = True
            self.getval = lambda varname: self.alt[varname]
        else:
            self.stateless = False
            if this_posmodel is None:
                import posmodel
                this_posmodel = posmodel.PosModel()
            self.posmodel = this_posmodel
            self.alt_override = False  # allows alternate calibration values to temporarily override PosState values
            self.getval = lambda varname: (  # varname is a string
                self.alt[varname] if self.alt_override
                else self.posmodel.state._val[varname]
                )                            

    # SHAFT RANGES
    def shaft_ranges(self, range_limits):
        """
        Returns a set of range limits for the theta and phi axes. The argument
        range_limits is a string:
            'full':         means from hardstop-to-hardstop
            'targetable':   restricts range by excluding the debounce and
                            backlash clearance zones near the hardstops
            'exact':        means theta range of [-179.999999999,180] and phi
                            range of [0,180]
        For debugging purposes, once can alternatively argue specific numeric
        values of the form [[minT, maxT], [minP,maxP]]
        """
        if self.stateless:
            return self.stateless_range_limits
        if isinstance(range_limits, (list, tuple)):
            return range_limits
        if range_limits == 'full':
            return [self.posmodel.full_range_posintT, self.posmodel.full_range_posintP]
        if range_limits == 'targetable':
            return [self.posmodel.targetable_range_posintT, self.posmodel.targetable_range_posintP]
        if range_limits == 'exact':
            return self.exact_range_limits
        print(f'bad range_limits argument: {range_limits}')
        return None
        
    def construct(self, coord_in, coord_out):
        '''Utility to construct a transform function using strings describing
        the coordinates in and out.'''
        try:
            for coord in [coord_in, coord_out]:
                assert coord in {'posintTP', 'poslocTP', 'poslocXY', 'flatXY', 'obsXY', 'QS', 'ptlXY'}
            assert coord_in != coord_out
            func_name = f'{coord_in}_to_{coord_out}'
            assert hasattr(self, func_name)
            handle = eval(f'self.{func_name}')
            return handle
        except:
            return None

    # LOWEST LEVEL CALIBRATED XY <--> TP CONVERSIONS
    # These two methods grab calibration values and then call the fundametnal
    # xy2tp() and tp2xy() methods.
    def poslocTP_to_poslocXY(self, poslocTP):
        ''' input is list or tuple or 1D array '''
        r = [self.getval('LENGTH_R1'), self.getval('LENGTH_R2')]
        return xy2tp.tp2xy(poslocTP, r)  # return (poslocX, poslocY)

    def poslocXY_to_poslocTP(self, poslocXY, range_limits='full',
                             t_guess=None, t_guess_tol=pc.default_t_guess_tol):
        '''Converts a poslocXY coordinate pair to poslocTP.
        
        INPUTS:  poslocXY ... 1x2 list or tuple or array
                 range_limits ... see definitions in shaft_ranges()
                 t_guess ... optional theta guess, in poslocTP system
                 t_guess_tol ... optional tol value on theta guess
        
        OUTPUTS: (poslocTP, unreachable)
                   
        Regarding behavior of t_guess and t_guess_tol, as well as meaning of the
        "unreachable" output boolean, see detailed comments in the xy2tp module.
        '''
        posintT_range, posintP_range = self.shaft_ranges(range_limits)
        poslocTP_min = self.posintTP_to_poslocTP([posintT_range[0], posintP_range[0]])
        poslocTP_max = self.posintTP_to_poslocTP([posintT_range[1], posintP_range[1]])
        posloc_ranges = [[poslocTP_min[0], poslocTP_max[0]],  # T min, T max
                         [poslocTP_min[1], poslocTP_max[1]]]  # P min, P max
        r = [self.getval('LENGTH_R1'), self.getval('LENGTH_R2')]
        return xy2tp.xy2tp(poslocXY, r, posloc_ranges, t_guess, t_guess_tol)

    # OFFSET TRANSFORMATIONS
    def posintTP_to_poslocTP(self, posintTP):
        """
        input:  list or tuple of internally-tracked expected position of
                gearmotor shafts at output of gear heads
        output: (posT, posP) expected position of fiber tip including offsets
                and calibrations in petal local CS
        """
        poslocT = posintTP[0] + self.getval('OFFSET_T')
        poslocP = posintTP[1] + self.getval('OFFSET_P')
        return poslocT, poslocP

    def poslocTP_to_posintTP(self, poslocTP):
        """
        input:  list or tuple of expected position of fiber tip including
                offsets and calibrations in petal local CS
        output: (intT, intP) internally-tracked expected position of
                gearmotor shafts at output of gear heads
        """
        posintT = poslocTP[0] - self.getval('OFFSET_T')
        posintP = poslocTP[1] - self.getval('OFFSET_P')
        return posintT, posintP

    def poslocXY_to_flatXY(self, poslocXY):
        ''' input is list or tuple or 1D array '''
        flatX = poslocXY[0] + self.getval('OFFSET_X')
        flatY = poslocXY[1] + self.getval('OFFSET_Y')
        return flatX, flatY

    def flatXY_to_poslocXY(self, flatXY):
        ''' input is list or tuple or 1D array '''
        poslocX = flatXY[0] - self.getval('OFFSET_X')
        poslocY = flatXY[1] - self.getval('OFFSET_Y')
        return poslocX, poslocY

    # COMPOSITE TRANSFORMATIONS
    def posintTP_to_poslocXY(self, posintTP):
        ''' input is list or tuple '''
        poslocTP = self.posintTP_to_poslocTP(posintTP)
        return self.poslocTP_to_poslocXY(poslocTP)  # (poslocX, poslocY)

    def poslocXY_to_posintTP(self, poslocXY, range_limits='full',
                             t_guess=None, t_guess_tol=pc.default_t_guess_tol):
        ''' Composite transformation, performs poslocXY --> poslocTP --> posintTP.
        Note that this method returns a tuple, where the first item is the
        converted coordinates, and the second item is boolean stating whether
        or not the input coordinates were "unreachable" in the output system.
        Note: t_guess is *always* defined in the poslocTP coordinate system.
        '''
        poslocTP, unreachable = self.poslocXY_to_poslocTP(poslocXY, range_limits=range_limits,
                                                          t_guess=t_guess, t_guess_tol=t_guess_tol)
        return self.poslocTP_to_posintTP(poslocTP), unreachable  # (t, p), unr

    def obsXY_to_poslocXY(self, obsXY):
        ''' input is list or tuple '''
        QS = self.obsXY_to_QS(obsXY, cast=True).flatten()  # 1D arr
        return self.QS_to_poslocXY(QS)  # return (poslocX, poslocY)

    def QS_to_poslocXY(self, QS):
        ''' input is list or tuple '''
        flatXY = self.QS_to_flatXY(QS, cast=True).flatten()
        return self.flatXY_to_poslocXY(flatXY)  # (poslocX, poslocY)

    def poslocXY_to_QS(self, poslocXY):
        ''' input is list or tuple '''
        flatXY = self.poslocXY_to_flatXY(poslocXY)  # (flatX, flatY)
        QS = self.flatXY_to_QS(flatXY, cast=True).flatten()  # 1 x 2 array
        return tuple(QS)  # (Q, S)

    def posintTP_to_flatXY(self, posintTP):
        poslocXY = self.posintTP_to_poslocXY(posintTP)  # (poslocX, poslocY)
        return self.poslocXY_to_flatXY(poslocXY)  # return (flatX, flatY)

    def flatXY_to_posintTP(self, flatXY, range_limits='full',
                       t_guess=None, t_guess_tol=pc.default_t_guess_tol):
        """Composite transformation, performs obsXY --> posXY --> posintTP
        Note that this method returns a tuple, where the first item is the
        converted coordinates, and the second item is boolean stating whether
        or not the input coordinates were "unreachable" in the output system.
        Note: t_guess is *always* defined in the poslocTP coordinate system.
        """
        poslocXY = self.flatXY_to_poslocXY(flatXY)  # (poslocX, poslocY)
        return self.poslocXY_to_posintTP(poslocXY, range_limits=range_limits,
                                       t_guess=t_guess, t_guess_tol=t_guess_tol)

    def ptlXY_to_flatXY(self, ptlXY):
        '''Direct transformation from ptlXY to flatXY coordinates.
        Note that this short-circuits a similar (but 10x slower) implementation
        in petatransforms.'''
        Q_rad = math.atan2(ptlXY[1], ptlXY[0])
        R = math.hypot(ptlXY[0], ptlXY[1])
        S = pc.R2S_lookup(R)
        flatX = S * math.cos(Q_rad)
        flatY = S * math.sin(Q_rad)
        return (flatX, flatY)

    def flatXY_to_ptlXY(self, flatXY):
        '''Direct transformation from flatXY to ptlXY coordinates.
        Note that this short-circuits a similar (but 10x slower) implementation
        in petatransforms.'''
        Q_rad = math.atan2(flatXY[1], flatXY[0])
        S = math.hypot(flatXY[0], flatXY[1])
        R = pc.S2R_lookup(S)
        ptlX = R * math.cos(Q_rad)
        ptlY = R * math.sin(Q_rad)
        return (ptlX, ptlY)
    
    def ptlXY_to_poslocXY(self, ptlXY):
        ''' input is 2-element list or tuple like [x,y] '''
        flatXY = self.ptlXY_to_flatXY(ptlXY)
        return self.flatXY_to_poslocXY(flatXY)
        
    def ptlXY_to_posintTP(self, ptlXY, range_limits='full',
                       t_guess=None, t_guess_tol=pc.default_t_guess_tol):
        '''Composite transformation, performs ptlXY --> flatXY --> posintTP
        Note that this method returns a tuple, where the first item is the
        converted coordinates, and the second item is boolean stating whether
        or not the input coordinates were "unreachable" in the output system.
        Note: t_guess is *always* defined in the poslocTP coordinate system.
        '''
        flatXY = self.ptlXY_to_flatXY(ptlXY)
        return self.flatXY_to_posintTP(flatXY, range_limits=range_limits,
                                       t_guess=t_guess, t_guess_tol=t_guess_tol)
    
    def poslocXY_to_ptlXY(self, poslocXY):
        ''' input is 2-element list or tuple like [x,y] '''
        flatXY = self.poslocXY_to_flatXY(poslocXY)
        return self.flatXY_to_ptlXY(flatXY)

    def posintTP_to_ptlXY(self, posintTP):
        '''Composite transformation, performs posintTP --> flatXY --> ptlXY'''
        flatXY = self.posintTP_to_flatXY(posintTP)
        return self.flatXY_to_ptlXY(flatXY)

    def posintTP_to_QS(self, posintTP):
        """Composite transformation, performs posintTP --> flatXY --> QS"""
        flatXY = self.posintTP_to_flatXY(posintTP)  # ptl local (flatX, flatY)
        QS = self.flatXY_to_QS(flatXY, cast=True).flatten()  # 1D array
        return tuple(QS)

    def QS_to_posintTP(self, QS, range_limits='full',
                       t_guess=None, t_guess_tol=pc.default_t_guess_tol):
        '''Composite transformation, performs QS --> flatXY --> posintTP
        Note that this method returns a tuple, where the first item is the
        converted coordinates, and the second item is boolean stating whether
        or not the input coordinates were "unreachable" in the output system.
        Note: t_guess is *always* defined in the poslocTP coordinate system.
        '''
        flatXY = self.QS_to_flatXY(QS, cast=True).flatten()  # 1D array
        return self.flatXY_to_posintTP(flatXY, range_limits=range_limits,
                                       t_guess=t_guess, t_guess_tol=t_guess_tol)

    def obsXY_to_posintTP(self, obsXY, range_limits='full',
                       t_guess=None, t_guess_tol=pc.default_t_guess_tol):
        """Composite transformation, performs obsXY --> ptlXY --> posintTP
        Note that this method returns a tuple, where the first item is the
        converted coordinates, and the second item is boolean stating whether
        or not the input coordinates were "unreachable" in the output system.
        Note: t_guess is *always* defined in the poslocTP coordinate system.
        """
        ptlXY = self.obsXY_to_ptlXY(obsXY)
        return self.ptlXY_to_posintTP(ptlXY, range_limits=range_limits,
                                      t_guess=t_guess, t_guess_tol=t_guess_tol)

    def posintTP_to_obsXY(self, posintTP):
        """Composite transformation, performs posintTP --> ptlXY --> obsXY"""
        ptlXY = self.posintTP_to_ptlXY(posintTP)
        return self.ptlXY_to_obsXY(ptlXY)
        
    def obsXY_to_ptlXY(self, obsXY):
        """Wrapper for similar petaltransforms 3D function. Uses focal surface
        asphere definition to generate an approximate intermediate Z value."""
        R = math.hypot(obsXY[0], obsXY[1])
        obsXYZ = [obsXY[0], obsXY[1], pc.R2Z_lookup(R)] # Z(R(obsXY)) --> imperfect (but very close) invertibilty with posintTP_to_obsXY
        ptlXYZ = self.obsXYZ_to_ptlXYZ(obsXYZ, cast=True)
        return [float(ptlXYZ[0]), float(ptlXYZ[1])]
    
    def ptlXY_to_obsXY(self, ptlXY):
        """Wrapper for similar petaltransforms 3D function. Uses focal surface
        asphere definition to generate an approximate intermediate Z value."""
        R = math.hypot(ptlXY[0], ptlXY[1])
        ptlXYZ = [ptlXY[0], ptlXY[1], pc.R2Z_lookup(R)] # Z(R(ptlXY)) --> imperfect (but very close) invertibilty with obsXY_to_posintTP
        obsXYZ = self.ptlXYZ_to_obsXYZ(ptlXYZ, cast=True)
        return [float(obsXYZ[0]), float(obsXYZ[1])]        
        
    # VECTOR ADDITIONS AND SUBTRACTIONS FOR MOTOR SHAFT COORDINATES
    def addto_posintTP(self, posintTP0, dtdp, range_wrap_limits='full'):
        """Returns tp corresponding to tp0 + dtdp.
        The range_wrap_limits option can be any of the values for the
        shaft_ranges method, or 'none'. If 'none', then the returned point is
        a simple vector addition with no special checks for angle-wrapping
        across positioner's theta = +/-180 deg.
        """
        if range_wrap_limits != 'none':
            posintT_range = self.shaft_ranges(range_wrap_limits)[pc.T]
            dtdp = PosTransforms._wrap_theta(posintTP0, dtdp, posintT_range)
        return PosTransforms.vector_add(posintTP0, dtdp)

    def delta_posintTP(self, posintTP0, posintTP1, range_wrap_limits='full'):
        """Returns dtdp corresponding to tp0 - tp1, or final - initial
        The range_wrap_limits option can be any of the values for the
        shaft_ranges method, or 'none'. If 'none', then the returned delta is
        a simple vector subtraction with no special checks for angle-wrapping
        across positioner's theta = +/-180 deg.
        """
        dtdp = PosTransforms.vector_delta(posintTP0, posintTP1)
        if range_wrap_limits != 'none':
            posintT_range = self.shaft_ranges(range_wrap_limits)[pc.T]
            dtdp = PosTransforms._wrap_theta(posintTP1, dtdp, posintT_range)
        return dtdp

    def addto_poslocTP(self, poslocTP0, dtdp, range_wrap_limits='full'):
        """Returns tp corresponding to tp0 + dtdp.
        The range_wrap_limits option can be any of the values for the
        shaft_ranges method, or 'none'. If 'none', then the returned point is
        a simple vector addition with no special checks for angle-wrapping
        across positioner's theta = +/-180 deg.
        """
        posintTP0 = self.poslocTP_to_posintTP(poslocTP0)
        posintTP1 = self.addto_posintTP(posintTP0, dtdp, range_wrap_limits)
        return self.posintTP_to_poslocTP(posintTP1)  # return tuple coords

    def delta_poslocTP(self, poslocTP0, poslocTP1, range_wrap_limits='full'):
        """Returns dtdp corresponding to tp0 - tp1.
        The range_wrap_limits option can be any of the values for the
        shaft_ranges method, or 'none'. If 'none', then the returned delta is
        a simple vector subtraction with no special checks for angle-wrapping
        across positioner's theta = +/-180 deg.
        """
        posintTP0 = self.poslocTP_to_posintTP(poslocTP0)
        posintTP1 = self.poslocTP_to_posintTP(poslocTP1)
        return self.delta_posintTP(posintTP0, posintTP1, range_wrap_limits)

    # VECTOR ADDITION AND SUBTRACTION FOR CARTESIAN AND POLAR COORDINATES
    @staticmethod
    def vector_delta(uv0, uv1):
        """Generic vector difference uv0 - uv1."""
        return [uv0[0] - uv1[0], uv0[1] - uv1[1]]

    @staticmethod
    def vector_add(uv0, uv1):
        """Generic vector addition uv0 + uv1."""
        return [uv0[0] + uv1[0], uv0[1] + uv1[1]]

    @staticmethod
    def addto_XY(xy0, dxdy):
        """Returns xy corresponding to xy0 + dxdy."""
        return PosTransforms.vector_add(xy0, dxdy)

    @staticmethod
    def addto_QS(qs0, dqds):
        """Returns qs corresponding to qs0 + dqds."""
        return PosTransforms.vector_add(qs0, dqds)

    @staticmethod
    def delta_XY(xy0, xy1):
        """Returns dxdy corresponding to xy0 - xy1."""
        return PosTransforms.vector_delta(xy0, xy1)

    @staticmethod
    def delta_QS(qs0, qs1):
        """Returns dqds corresponding to qs0 - qs1."""
        return PosTransforms.vector_delta(qs0, qs1)

    # ANGLE WRAPPING
    @staticmethod
    def _wrap_theta(tp0, dtdp, posintT_range):
        """
        tp0             : initial TP positions
        dtdp            : delta TP movement
        posintT_range   : allowed range of internal theta, tuple or list

        Returns a modified dtdp after appropriately wrapping the delta theta
        to not cross a physical hardstop. Phi angle is untouched.
        """
        ti, dt, dp = tp0[0], dtdp[0], dtdp[1]  # t initial, dt, dp
        wrapped_dt = dt - 360*pc.sign(dt)
        tf = ti + dt
        wrapped_tf = ti + wrapped_dt
        if min(posintT_range) <= wrapped_tf <= max(posintT_range):
            if ((min(posintT_range) > tf or max(posintT_range) < tf)
                    or abs(wrapped_dt) < abs(dt)):
                dt = wrapped_dt
        return dt, dp

    @staticmethod
    def _wrap_consecutive_angles(angles, expected_direction):
        """
        input angles is a list of [120, 150, 180, 220, 300...]
        Wrap angles in one expected direction. It is expected that the
        physical deltas we are trying to wrap all increase or all decrease
        sequentially. In other words, that the sequence of angles is only
        going one way around the circle.
        """
        wrapped = [angles[0]]
        for i in range(1, len(angles)):
            delta = angles[i] - wrapped[i-1]
            while pc.sign(delta) != expected_direction and pc.sign(delta) != 0:
                delta += expected_direction * 360
            wrapped.append(wrapped[-1] + delta)
        return wrapped

    @staticmethod
    def _centralize_angular_offset(offset_angle):
        """
        A special unwrapping check for OFFSET_T and OFFSET_P angles,
        for which we are always going to want to default to the option closer
        to 0 deg. Hence if our calibration routine calculates a best fit
        value for example of OFFSET_T or OFFSET_P = 351 deg, then the real
        setting we want to apply should clearly instead be -9.
        """
        try_plus = offset_angle % 360
        try_minus = offset_angle % -360
        if abs(try_plus) <= abs(try_minus):
            return try_plus
        else:
            return try_minus

if __name__ == '__main__':
    '''
    try several gamma rotaion values here, e.g. 0, 36 deg, 180 deg
    '''
    petal_alignment = {'Tx': 0, 'Ty': 0, 'Tz': 0,
                       'alpha': 0, 'beta': 0, 'gamma': 0/180*math.pi}
    trans = PosTransforms(petal_alignment=petal_alignment)
    state = trans.posmodel.state
    # device location 526 on petal
    state._val['OFFSET_X'], state._val['OFFSET_Y'] = 346.797988, 194.710169
    print(f'posstate values:\n{state._val}')
    posintTP = (0, 120)
    poslocTP = trans.posintTP_to_poslocTP(posintTP)
    print(f'poslocTP = {poslocTP}')
    posintTP = trans.poslocTP_to_posintTP(poslocTP)
    print(f'posintTP = {posintTP}')
    poslocXY = trans.poslocTP_to_poslocXY(poslocTP)
    print(f'poslocXY = {poslocXY}')
    print(f'poslocTP, unreachable = {trans.poslocXY_to_poslocTP(poslocXY)}')
    flatXY = trans.poslocXY_to_flatXY(poslocXY)
    print(f'flatXY = {flatXY}')
    print(f'poslocXY = {trans.flatXY_to_poslocXY(flatXY)}')
    print(f'poslocXY = {trans.posintTP_to_poslocXY(posintTP)}')
    print(f'posintTP, unreachable = {trans.poslocXY_to_posintTP(poslocXY)}')
    QS = trans.poslocXY_to_QS(poslocXY)
    print(f'QS = {QS}')
    print(f'poslocXY = {trans.QS_to_poslocXY(QS)}')
    print(f'flatXY = {trans.posintTP_to_flatXY(posintTP)}')
    print(f'posintTP, unreachable = {trans.flatXY_to_posintTP(flatXY)}')
    ptlXY = trans.posintTP_to_ptlXY(posintTP)
    print(f'ptlXY = {ptlXY}')
    print(f'posintTP = {trans.ptlXY_to_posintTP(ptlXY)}')
    QS = trans.posintTP_to_QS(posintTP)
    print(f'QS = {QS}')
    print(f'posintTP, unreachable = {trans.QS_to_posintTP(QS)}')
    print(f'flatXY = {trans.QS_to_flatXY(QS, cast=True).flatten()}')

    from posstate import PosState
    from posmodel import PosModel
    state = PosState('M00677')
    model = PosModel(state=state)
    trans = model.trans
    print(model.expected_current_position)
