```python name='pc{0:02} positioners not tested and disabled', echo=False
df = pd.DataFrame(pi.find_by_arbitrary_keys(PETAL_LOC={0}))
df = df[df['DEVICE_TYPE']=='POS']
posids_all = set(df['DEVICE_ID'].unique())
if hasattr(data, 'posids_disabled_pc'):
	posids_tested = set(data.posids_pc[{0}]) |  data.posids_disabled_pc[{0}]
	posids_disabled = data.posids_disabled_pc[{0}]
else:
	posids_tested = set(data.posids_pc[{0}])
	posids_disabled = set()
posids_untested = sorted(posids_all - posids_tested)

grades_pc = data.gradedf[data.gradedf['PCID'] == {0}]
posids_grade = {{}}
for grade in grades:
	mask = grades_pc['grade'] == grade
	posids_grade[grade] = sorted(data.gradedf[mask].index)
```

### PC<%={0:02}%>

``<%=len(posids_tested)%>`` positioners were tested, of which
``<%=len(posids_disabled)%>`` were disabled during test:
``<%=sorted(posids_disabled)%>``
```python name='pc{0:02} positioners disabled', echo=False, results='raw'
if not hasattr(data, 'posids_disabled_pc'):
	print('Disabled positioners were not recorded in old test, please check log.')
```
``<%=len(posids_untested)%>`` positioners were not tested:
``<%=sorted(posids_untested)%>``

```python name='pc{0:02} temp, grade distribution', echo=False, width='500px'
if data.db_telemetry_available:
    plot_posfid_temp(pcid={0})
else:
    print('DB telemetry query unavailable on this platform\n')
grade_counts = plot_grade_dist(pcid={0})
```

Error measures by grades
```python name='pc{0:02} median stats by grade', echo=False
rows = []
for grade in grades[:-1]:
	df = grades_pc[grades_pc['grade']==grade]
	row = dict()
	for col in df.columns:
		if 'max' in col:
			row[col] = df[col].max()
		elif 'rms' in col:
			row[col] = np.sqrt(np.mean(np.square(df[col])))
	rows.append(row)
pd.DataFrame(rows, index=grades[:-1])
```

```python name='pc{0:02} error distribution', echo=False, width='linewidth'
plot_error_dist(pcid={0})
n_abnormal = (df_abnormal['PCID']=={0}).index.droplevel(0).unique().size
```

##### Abnormal status: ``<%=n_abnormal%>`` positioners
```python name='pc{0:02} abnormal flags', echo=False, results='verbatim'
abnormal_pc = abnormal_pos_df(pcid={0})
gradedf_pc = data.gradedf[data.gradedf['PCID']=={0}]
gradedf_pc_maxb = gradedf_pc[gradedf_pc['err_0_max']>200]
gradedf_pc_rmsc = gradedf_pc[gradedf_pc['err_corr_rms']>30]
posids_exclude = sorted((set(abnormal_pc.index) | set(gradedf_pc_maxb.index)
                  | set(gradedf_pc_rmsc.index)))
abnormal_pc.reset_index().astype(int, errors='ignore')
```

##### Max blind move error > 200 μm: ``<%=len(gradedf_pc_maxb)%>`` positioners
```python name='pc{0:02} max blind', echo=False, results='verbatim'
gradedf_pc_maxb.iloc[:, :6].reset_index().astype(int, errors='ignore')
```

##### RMS corrective move error > 30 μm: ``<%=len(gradedf_pc_rmsc)%>`` positioners
```python name='pc{0:02} rms corr', echo=False, results='raw'
gradedf_pc_rmsc.iloc[:, :6].reset_index().astype(int, errors='ignore')
```

##### Move errors by targets excluding ``<%=len(posids_exclude)%>`` outliers (μm)
```python name='pc{0:02} errors by targets', echo=False
movedf_filtered = (data.movedf.drop(posids_exclude, level=1)
                   [[col for col in data.movedf.columns if 'err_xy_' in col]]
                   * 1000)  # convert to microns
max_df = movedf_filtered.max(axis=0, level=0)
# mean_df = movedf_filtered.mean(axis=0, level=0)
rms_df = np.sqrt(np.square(movedf_filtered).mean(axis=0, level=0))
df = max_df.join(rms_df, lsuffix='_max', rsuffix='_rms')
df.rename(columns={{col: col.replace('err_xy_', 'submove_') for col in df.columns}},
          inplace=True)
df.reset_index().astype(int, errors='ignore')
```

##### Move errors by submoves excluding ``<%=len(posids_exclude)%>`` outliers (μm)

```python name='pc{0:02} errors by submoves', echo=False
max_series = movedf_filtered.max(axis=0)
rms_series = np.sqrt(np.square(movedf_filtered).mean(axis=0))
median_series = movedf_filtered.mean(axis=0)
pd.DataFrame([max_series, rms_series, median_series],
             index=['max', 'rms', 'median']).T.astype(int, errors='ignore')
```

##### Move error maps excluding ``<%=len(posids_exclude)%>`` outliers (μm)
```python, name='pc{0:02} grade A error distribution', echo=False, width='linewidth', results='verbatim'
plot_error_heatmaps(pcid={0}, posids_exclude=posids_exclude)

def plot_grade_section(grade):
	if grade_counts[grade] > 0:
		plot_error_dist(pcid={0}, grade=grade)
		if set(posids_grade[grade]) & set(posids_exclude):
			plot_error_dist(pcid={0}, grade=grade, posids_exclude=posids_exclude)
```

##### Grade A: ``<%=grade_counts['A']%>`` positioners
```python, name='pc{0:02} grade A error distribution', echo=False, width='linewidth', results='hidden'
plot_grade_section('A')
```
``<%=posids_grade['A']%>``

##### Grade B: ``<%=grade_counts['B']%>`` positioners
```python, name='pc{0:02} grade B error distribution', echo=False, width='linewidth', results='hidden'
plot_grade_section('B')
```
``<%=posids_grade['B']%>``

##### Grade C: ``<%=grade_counts['C']%>`` positioners
```python, name='pc{0:02} grade C error distribution', echo=False, width='linewidth', results='hidden'
plot_grade_section('C')
```
``<%=posids_grade['C']%>``

##### Grade D: ``<%=grade_counts['D']%>`` positioners
```python, name='pc{0:02} grade D error distribution', echo=False, width='linewidth', results='hidden'
plot_grade_section('D')
```
``<%=posids_grade['D']%>``

##### Grade F: ``<%=grade_counts['F']%>`` positioners
```python, name='pc{0:02} grade F error distribution', echo=False, width='linewidth', results='hidden'
plot_grade_section('F')
```
``<%=posids_grade['F']%>``

##### Grade N/A: ``<%=grade_counts['N/A']%>`` positioners
``<%=posids_grade['N/A']%>``
